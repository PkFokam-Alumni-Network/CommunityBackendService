# core/journey_middleware.py
from starlette.middleware.base import BaseHTTPMiddleware
from fastapi import Request
from core.database import get_db
from repository.user_journey_repository import UserJourneyRepository
from repository.session_repository import SessionRepository
from datetime import datetime, timezone
import time
from concurrent.futures import ThreadPoolExecutor
from typing import Optional, Dict, Any
from core.logging_config import LOGGER
journey_executor = ThreadPoolExecutor(max_workers=5, thread_name_prefix="journey_")


class JourneyTrackingMiddleware(BaseHTTPMiddleware):
    """
    Middleware to track user journey through the application.
    Logs all authenticated user actions asynchronously without blocking responses.
    """
    
    EXCLUDED_PATHS = {"/docs", "/redoc", "/openapi.json", "/health", "/"}
    
    async def dispatch(self, request: Request, call_next):
        if request.url.path in self.EXCLUDED_PATHS:
            return await call_next(request)
        
        session_token = request.cookies.get("session_token")
        user_id = None
        
        if session_token:
            db = next(get_db())
            try:
                session_repo = SessionRepository()
                session = session_repo.get_by_token(db, session_token)
                
                if session and session.expires_at > datetime.now(timezone.utc):
                    user_id = session.user_id
            except Exception as e:
                LOGGER.error(f"Error getting user session: {e}")
            finally:
                db.close()
        
        start_time = time.time()
        response = await call_next(request)
        process_time = time.time() - start_time
        
        if user_id:
            action = self._get_action_from_route(request)
            
            extra_metadata = {
                "process_time": process_time,
                "status_code": response.status_code,
                "path_params": dict(request.path_params),
                "query_params": dict(request.query_params),
            }
            
            ip_address = request.client.host if request.client else None
            
            user_agent = request.headers.get("user-agent")
            
            journey_executor.submit(
                self._log_journey_sync,
                user_id=user_id,
                action=action,
                session_token=session_token,
                endpoint=request.url.path,
                method=request.method,
                extra_metadata=extra_metadata,
                ip_address=ip_address,
                user_agent=user_agent,
            )
        
        return response
    
    def _log_journey_sync(
        self,
        user_id: int,
        action: str,
        session_token: Optional[str] = None,
        endpoint: Optional[str] = None,
        method: Optional[str] = None,
        extra_metadata: Optional[Dict[str, Any]] = None,
        ip_address: Optional[str] = None,
        user_agent: Optional[str] = None,
    ) -> None:
        """
        Synchronous journey logging executed in thread pool.
        This runs in a separate thread and doesn't block the main request.
        """
        try:
            db = next(get_db())
            try:
                journey_repo = UserJourneyRepository()
                journey_repo.create_log(
                    db=db,
                    user_id=user_id,
                    action=action,
                    session_token=session_token,
                    endpoint=endpoint,
                    method=method,
                    extra_metadata=extra_metadata,
                    ip_address=ip_address,
                    user_agent=user_agent,
                )
            finally:
                db.close()
        except Exception as e:
            LOGGER.error(f"Error logging user journey: {e}")
    
    def _get_action_from_route(self, request: Request) -> str:
        """
        Extract action from FastAPI route metadata or create from path.
        Priority:
        1. Route's operation_id (manually set)
        2. Route's name (auto-generated by FastAPI)
        3. Pattern matching using action mapper
        4. Fallback (method + path)
        """
        route = request.scope.get("route")
        
        # Priority 1: Explicit operation_id
        if route and hasattr(route, "operation_id") and route.operation_id:
            return route.operation_id
        
        # Priority 2: Route name (for special cases)
        if route and hasattr(route, "name") and route.name:
            # Filter out generic names like "create_user_api_users_post"
            if not self._is_generic_route_name(route.name):
                return route.name
        
        # Priority 3 & 4: Pattern matching or fallback
        from utils.journey_config import action_mapper
        return action_mapper.get_action(request.url.path, request.method)
    
    def _is_generic_route_name(self, name: str) -> bool:
        """
        Check if route name is auto-generated by FastAPI and not useful.
        FastAPI auto-generates names like "get_user_api_users__user_id__get"
        """
        return name.endswith(('_get', '_post', '_put', '_patch', '_delete'))